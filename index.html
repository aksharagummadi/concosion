<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Stickman Concussion Adventure</title>
    <style>
      :root {
        --sky: #bde8ff;
        --floor: #d8f5c1;
        --hospital: #f5f0ff;
        --panel: rgba(255, 255, 255, 0.85);
        --accent: #ff7a7a;
        --ink: #2c2c2c;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Comic Sans MS", "Trebuchet MS", system-ui, sans-serif;
        background: linear-gradient(180deg, var(--sky), #ffffff);
        color: var(--ink);
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
      }

      #game-wrapper {
        width: 900px;
        max-width: 96vw;
        aspect-ratio: 16 / 9;
        background: var(--hospital);
        border: 5px solid var(--ink);
        border-radius: 18px;
        position: relative;
        overflow: hidden;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.15);
      }

      #scene {
        position: absolute;
        inset: 0;
        background: linear-gradient(180deg, #f6fbff 0%, #fff5f5 55%, var(--floor) 55%);
        transition: background 0.6s ease;
      }

      #scene.street {
        background: linear-gradient(180deg, #bde8ff 0%, #9fd5ff 55%, #f2e4b7 55%);
      }

      .ground-line {
        position: absolute;
        left: 0;
        right: 0;
        height: 6px;
        background: #86c27c;
        top: 55%;
      }

      #player,
      .npc {
        position: absolute;
        width: 48px;
        height: 96px;
      }

      .stick-body {
        position: absolute;
        left: 50%;
        top: 18px;
        width: 6px;
        height: 60px;
        background: var(--ink);
        transform: translateX(-50%);
      }

      .stick-head {
        position: absolute;
        top: 0;
        left: 50%;
        width: 30px;
        height: 30px;
        border: 4px solid var(--ink);
        border-radius: 50%;
        transform: translateX(-50%);
        background: #fff;
      }

      .stick-arm {
        position: absolute;
        width: 32px;
        height: 6px;
        background: var(--ink);
        top: 40px;
      }

      .stick-arm.left {
        left: 4px;
        transform: rotate(-20deg);
        transform-origin: left center;
      }

      .stick-arm.right {
        right: 4px;
        transform: rotate(20deg);
        transform-origin: right center;
      }

      .stick-leg {
        position: absolute;
        width: 6px;
        height: 36px;
        background: var(--ink);
        bottom: 0;
      }

      .stick-leg.left {
        left: 16px;
        transform: rotate(8deg);
      }

      .stick-leg.right {
        right: 16px;
        transform: rotate(-8deg);
      }

      #player.bedridden {
        transform: rotate(90deg);
      }

      #player .speech {
        position: absolute;
        top: -22px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 12px;
        background: #fff;
        padding: 4px 6px;
        border-radius: 8px;
        border: 2px solid var(--ink);
        display: none;
      }

      #player.talking .speech {
        display: block;
      }

      .npc {
        filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.2));
      }

      .npc .label {
        position: absolute;
        top: -22px;
        left: 50%;
        transform: translateX(-50%);
        background: #fff;
        border: 2px solid var(--ink);
        padding: 2px 6px;
        border-radius: 8px;
        font-size: 12px;
      }

      #hint-panel {
        position: absolute;
        top: 18px;
        left: 18px;
        width: 260px;
        background: var(--panel);
        border: 3px solid var(--ink);
        border-radius: 14px;
        padding: 12px 14px;
        font-size: 14px;
      }

      #hint-panel h3 {
        margin: 0 0 6px;
        font-size: 16px;
      }

      #dialogue {
        position: absolute;
        left: 50%;
        bottom: 18px;
        transform: translateX(-50%);
        width: min(640px, 92%);
        background: rgba(255, 255, 255, 0.95);
        border: 4px solid var(--ink);
        border-radius: 16px;
        padding: 16px;
        text-align: center;
        display: none;
      }

      #dialogue.visible {
        display: block;
      }

      #dialogue .speaker {
        font-weight: 700;
        margin-bottom: 6px;
      }

      .puzzle-overlay {
        position: absolute;
        inset: 0;
        background: rgba(0, 0, 0, 0.35);
        display: none;
        align-items: center;
        justify-content: center;
        padding: 16px;
      }

      .puzzle-overlay.visible {
        display: flex;
      }

      .puzzle-panel {
        background: #fff;
        border: 4px solid var(--ink);
        border-radius: 18px;
        padding: 16px 20px;
        width: min(360px, 90%);
        text-align: center;
      }

      .puzzle-panel h4 {
        margin: 0 0 8px;
        font-size: 18px;
      }

      #sticky-note {
        background: #fff9a9;
        border: 2px solid #d4c863;
        border-radius: 12px;
        padding: 6px 10px;
        font-size: 13px;
        margin: 8px auto;
        width: fit-content;
      }

      #keypad-display {
        font-size: 22px;
        letter-spacing: 4px;
        padding: 8px 0;
        border: 2px dashed var(--ink);
        border-radius: 10px;
        margin-bottom: 10px;
      }

      #keypad-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
      }

      .keypad-key {
        background: #f2f2f2;
        border: 2px solid var(--ink);
        border-radius: 10px;
        padding: 10px 0;
        font-size: 18px;
        font-weight: 700;
      }

      .keypad-key.selected {
        background: var(--accent);
        color: #fff;
      }

      #keypad-hint {
        margin-top: 10px;
        font-size: 12px;
      }

      .lock-layer {
        display: flex;
        justify-content: center;
        gap: 6px;
        margin: 10px 0;
        font-size: 12px;
      }

      .lock-layer span {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 2px solid var(--ink);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        background: #f5f5f5;
      }

      .lock-layer span.active {
        background: var(--accent);
        color: #fff;
      }

      .lock-layer span.target {
        border-color: #1a8f4e;
        box-shadow: 0 0 0 2px rgba(26, 143, 78, 0.3);
      }

      .lock-controls {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
        margin-top: 10px;
      }

      .lock-button,
      .wire-terminal,
      .memory-button {
        border: 2px solid var(--ink);
        border-radius: 10px;
        padding: 8px;
        font-weight: 700;
        cursor: pointer;
        background: #f2f2f2;
      }

      .lock-button {
        font-size: 12px;
      }

      .wire-board {
        display: grid;
        grid-template-columns: 1fr auto 1fr;
        gap: 12px;
        align-items: center;
        margin-top: 12px;
      }

      .wire-column {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .wire-terminal.connected {
        background: #c7f5c0;
      }

      .wire-terminal.selected {
        outline: 3px solid var(--accent);
      }

      .wire-links {
        font-size: 12px;
        line-height: 1.4;
      }

      .memory-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        margin-top: 12px;
      }

      .memory-button {
        height: 70px;
        font-size: 0;
      }

      .memory-button.red {
        background: #ff6b6b;
      }

      .memory-button.blue {
        background: #6ba9ff;
      }

      .memory-button.green {
        background: #6bff95;
      }

      .memory-button.yellow {
        background: #ffe26b;
      }

      .memory-button.active {
        box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.8) inset;
        filter: brightness(1.15);
      }

      #memory-panel {
        position: absolute;
        top: 18px;
        right: 18px;
        width: 200px;
        background: var(--panel);
        border: 3px solid var(--ink);
        border-radius: 14px;
        padding: 10px 12px;
        font-size: 13px;
      }

      #memory-panel ul {
        padding-left: 18px;
        margin: 6px 0 0;
      }

      #scene-message {
        position: absolute;
        top: 60%;
        right: 40px;
        background: #fff;
        border: 3px dashed var(--accent);
        padding: 8px 12px;
        border-radius: 12px;
        font-size: 14px;
        display: none;
      }

      #scene-message.visible {
        display: block;
      }

      @media (max-width: 640px) {
        #hint-panel,
        #memory-panel {
          width: 180px;
          font-size: 12px;
        }

        .puzzle-panel {
          width: min(320px, 92%);
        }
      }
    </style>
  </head>
  <body>
    <div id="game-wrapper">
      <div id="scene">
        <div class="ground-line"></div>
        <div id="player" class="bedridden">
          <div class="speech">Hello?</div>
          <div class="stick-head"></div>
          <div class="stick-body"></div>
          <div class="stick-arm left"></div>
          <div class="stick-arm right"></div>
          <div class="stick-leg left"></div>
          <div class="stick-leg right"></div>
        </div>
        <div id="nurse" class="npc">
          <div class="label">Nurse?</div>
          <div class="stick-head"></div>
          <div class="stick-body"></div>
          <div class="stick-arm left"></div>
          <div class="stick-arm right"></div>
          <div class="stick-leg left"></div>
          <div class="stick-leg right"></div>
        </div>
        <div id="kid" class="npc" hidden>
          <div class="label">Balloon Kid</div>
          <div class="stick-head"></div>
          <div class="stick-body"></div>
          <div class="stick-arm left"></div>
          <div class="stick-arm right"></div>
          <div class="stick-leg left"></div>
          <div class="stick-leg right"></div>
        </div>
        <div id="scene-message">Street demo unlocked!</div>
      </div>
      <div id="hint-panel">
        <h3>ðŸ’¡ Hint</h3>
        <div id="hint-text"></div>
      </div>
      <div id="memory-panel">
        <strong>Recovered Memories</strong>
        <ul id="memory-list"></ul>
      </div>
      <div id="dialogue">
        <div class="speaker" id="dialogue-speaker"></div>
        <div id="dialogue-text"></div>
      </div>
      <div id="keypad-overlay" class="puzzle-overlay">
        <div id="keypad" class="puzzle-panel">
          <h4>Hospital Door Keypad</h4>
          <div id="sticky-note">Sticky note: Code 428</div>
          <div id="keypad-display">---</div>
          <div id="keypad-grid"></div>
          <div id="keypad-hint">
            Use arrow keys to move. Each move onto a key presses it.
          </div>
          <div id="keypad-hint">Number keys also work.</div>
        </div>
      </div>
      <div id="lock-overlay" class="puzzle-overlay">
        <div class="puzzle-panel">
          <h4>Twist Lock Alignment</h4>
          <div>Align each ring on the green marker.</div>
          <div id="lock-layers"></div>
          <div class="lock-controls" id="lock-controls"></div>
          <div id="lock-message"></div>
        </div>
      </div>
      <div id="wires-overlay" class="puzzle-overlay">
        <div class="puzzle-panel">
          <h4>Wire Connection</h4>
          <div>Connect matching colors to restore power.</div>
          <div class="wire-board">
            <div class="wire-column" id="wire-left"></div>
            <div class="wire-links" id="wire-links">No connections yet.</div>
            <div class="wire-column" id="wire-right"></div>
          </div>
          <div id="wire-message"></div>
        </div>
      </div>
      <div id="memory-overlay" class="puzzle-overlay">
        <div class="puzzle-panel">
          <h4>Memory Echo Game</h4>
          <div>Watch the colors, then repeat the sequence.</div>
          <div id="memory-score">Score: 0 / 10</div>
          <div class="memory-grid" id="memory-grid"></div>
          <div id="memory-message"></div>
        </div>
      </div>
    </div>

    <script>
      const player = document.getElementById("player");
      const nurse = document.getElementById("nurse");
      const kid = document.getElementById("kid");
      const scene = document.getElementById("scene");
      const hintText = document.getElementById("hint-text");
      const dialogueBox = document.getElementById("dialogue");
      const dialogueSpeaker = document.getElementById("dialogue-speaker");
      const dialogueText = document.getElementById("dialogue-text");
      const memoryList = document.getElementById("memory-list");
      const sceneMessage = document.getElementById("scene-message");
      const keypadOverlay = document.getElementById("keypad-overlay");
      const keypadGrid = document.getElementById("keypad-grid");
      const keypadDisplay = document.getElementById("keypad-display");
      const lockOverlay = document.getElementById("lock-overlay");
      const lockLayersEl = document.getElementById("lock-layers");
      const lockControls = document.getElementById("lock-controls");
      const lockMessage = document.getElementById("lock-message");
      const wiresOverlay = document.getElementById("wires-overlay");
      const wireLeft = document.getElementById("wire-left");
      const wireRight = document.getElementById("wire-right");
      const wireLinks = document.getElementById("wire-links");
      const wireMessage = document.getElementById("wire-message");
      const memoryOverlay = document.getElementById("memory-overlay");
      const memoryGrid = document.getElementById("memory-grid");
      const memoryScore = document.getElementById("memory-score");
      const memoryMessage = document.getElementById("memory-message");

      const state = {
        canWalk: false,
        inDialogue: false,
        scene: "hospital",
        phase: "intro",
        memories: [],
        position: { x: 120, y: 320 },
      };

      const dialogueScripts = {
        nurse: [
          {
            speaker: "Stickman",
            text: "Goodbye. Tomato salad solves all problems. Why I have no tomato salad?",
          },
          {
            speaker: "Nurse",
            text: "I'm your nurse. You have a concussion, so we will go slow.",
          },
          {
            speaker: "Stickman",
            text: "Fish tanks are very tasty, especially ones with french fries",
          },
          {
            speaker: "Nurse",
            text: "Solve this keypad puzzle. The code is on the sticky note, but your fingers are scrambled.",
          },
          {
            speaker: "Nurse",
            text: "Each number you press becomes a different number. Figure out the right buttons.",
          },
        ],
        kid: [
          {
            speaker: "Balloon Kid",
            text: "My balloon flew away! Can you stand under the big sign?",
          },
          {
            speaker: "Stickman",
            text: "I will stand there and catch the red sky circle, maybe.",
          },
          {
            speaker: "Balloon Kid",
            text: "It dropped! You're a hero. Here, have a memory of snacks.",
          },
          {
            speaker: "Stickman",
            text: "SNACKS! I remember chewing. This is a delicious memory.",
          },
        ],
      };

      let dialogueQueue = [];
      const keypadLayout = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "clear", "0", "enter"];
      const scrambledMap = {
        0: "5",
        1: "3",
        2: "8",
        3: "1",
        4: "6",
        5: "0",
        6: "2",
        7: "9",
        8: "4",
        9: "7",
      };
      const targetCode = "428";
      let keypadSelection = 0;
      let keypadInput = "";
      let nurseApproachTimer;
      let nurseArrived = false;
      let introDialogueStarted = false;
      const lockTargets = [2, 2, 2];
      let lockLayers = [0, 4, 1];
      const wireColors = ["red", "blue", "green", "yellow"];
      let wireSelected = null;
      const wireConnections = new Set();
      const memoryColors = ["red", "blue", "green", "yellow"];
      let memorySequence = [];
      let memoryInputIndex = 0;
      let memoryLocked = false;

      function updateMemoryList() {
        memoryList.innerHTML = "";
        if (state.memories.length === 0) {
          const li = document.createElement("li");
          li.textContent = "None yet!";
          memoryList.appendChild(li);
          return;
        }
        state.memories.forEach((memory) => {
          const li = document.createElement("li");
          li.textContent = memory;
          memoryList.appendChild(li);
        });
      }

      function setHint(text) {
        hintText.textContent = text;
      }

      function setPlayerPosition() {
        player.style.left = `${state.position.x}px`;
        player.style.top = `${state.position.y}px`;
      }

      function placeCharacters() {
        setPlayerPosition();
        nurse.style.left = "720px";
        nurse.style.top = "260px";
        kid.style.left = "560px";
        kid.style.top = "260px";
      }

      function openDialogue(scriptKey) {
        dialogueQueue = [...dialogueScripts[scriptKey]];
        state.inDialogue = true;
        dialogueBox.classList.add("visible");
        showNextDialogue();
      }

      function showNextDialogue() {
        if (dialogueQueue.length === 0) {
          closeDialogue();
          return;
        }
        const line = dialogueQueue.shift();
        dialogueSpeaker.textContent = line.speaker;
        dialogueText.textContent = line.text;
      }

      function closeDialogue() {
        state.inDialogue = false;
        dialogueBox.classList.remove("visible");
        if (state.scene === "hospital" && state.phase === "intro") {
          startKeypadPuzzle();
        } else if (state.scene === "street" && !state.memories.includes("Remembering snacks")) {
          addMemory("Remembering snacks");
          setHint("You recovered a snack memory! Wander around with arrow keys.");
          sceneMessage.classList.add("visible");
        }
      }

      function unlockWalking() {
        state.canWalk = true;
        state.phase = "free";
        addMemory("Remembering walking");
        player.classList.remove("bedridden");
        setHint("You remembered how to walk! Use the arrow keys to move.");
      }

      function addMemory(memory) {
        if (!state.memories.includes(memory)) {
          state.memories.push(memory);
          updateMemoryList();
        }
      }

      function isColliding(a, b) {
        const aRect = a.getBoundingClientRect();
        const bRect = b.getBoundingClientRect();
        return !(
          aRect.right < bRect.left ||
          aRect.left > bRect.right ||
          aRect.bottom < bRect.top ||
          aRect.top > bRect.bottom
        );
      }

      function handleInteraction() {
        if (state.inDialogue) {
          showNextDialogue();
          return;
        }
        if (state.scene === "street" && isColliding(player, kid)) {
          openDialogue("kid");
        }
      }

      function movePlayer(dx, dy) {
        if (!state.canWalk) {
          player.classList.add("talking");
          setTimeout(() => player.classList.remove("talking"), 400);
          return;
        }
        if (state.inDialogue) {
          showNextDialogue();
          return;
        }
        const maxX = scene.clientWidth - 60;
        const maxY = scene.clientHeight - 120;
        state.position.x = Math.max(20, Math.min(maxX, state.position.x + dx));
        state.position.y = Math.max(200, Math.min(maxY, state.position.y + dy));
        setPlayerPosition();
        handleSceneExit();
        handleInteraction();
      }

      function handleSceneExit() {
        if (state.scene === "hospital" && state.position.x > scene.clientWidth - 80) {
          state.scene = "street";
          scene.classList.add("street");
          kid.hidden = false;
          nurse.hidden = true;
          state.position.x = 80;
          setPlayerPosition();
          setHint("Welcome outside! Find the kid and stand close to talk.");
        }
      }

      function onKeydown(event) {
        const key = event.key;
        const isArrowKey = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(key);
        const isNumberKey = /^\d$/.test(key);
        if (!isArrowKey && !isNumberKey) {
          return;
        }
        event.preventDefault();
        if (state.inDialogue) {
          showNextDialogue();
          return;
        }
        if (state.phase === "intro" && !state.inDialogue) {
          startIntroDialogue(true);
          return;
        }
        if (state.phase === "keypad") {
          if (isNumberKey) {
            pressKeypadKey(key);
          } else {
            handleKeypadInput(key);
          }
          return;
        }
        if (state.phase !== "free") {
          return;
        }
        const step = 16;
        if (key === "ArrowUp") movePlayer(0, -step);
        if (key === "ArrowDown") movePlayer(0, step);
        if (key === "ArrowLeft") movePlayer(-step, 0);
        if (key === "ArrowRight") movePlayer(step, 0);
      }

      document.addEventListener("keydown", onKeydown);

      function animateNurseApproach() {
        setHint("The nurse is walking over to check on you.");
        nurseArrived = false;
        nurseApproachTimer = setInterval(() => {
          const nurseX = Number.parseFloat(nurse.style.left) || 720;
          const targetX = state.position.x + 60;
          if (nurseX <= targetX) {
            clearInterval(nurseApproachTimer);
            nurseArrived = true;
            startIntroDialogue();
            return;
          }
          nurse.style.left = `${nurseX - 6}px`;
        }, 60);
      }

      function startIntroDialogue(forceSnap = false) {
        if (introDialogueStarted || state.inDialogue || state.phase !== "intro") {
          return;
        }
        introDialogueStarted = true;
        if (nurseApproachTimer) {
          clearInterval(nurseApproachTimer);
        }
        if (forceSnap || !nurseArrived) {
          nurse.style.left = `${state.position.x + 60}px`;
        }
        openDialogue("nurse");
      }

      function buildKeypad() {
        keypadGrid.innerHTML = "";
        keypadLayout.forEach((key, index) => {
          const button = document.createElement("div");
          button.className = "keypad-key";
          button.dataset.index = index;
          button.textContent = key === "clear" ? "CLR" : key === "enter" ? "OK" : key;
          keypadGrid.appendChild(button);
        });
        updateKeypadSelection();
      }

      function updateKeypadSelection() {
        keypadGrid.querySelectorAll(".keypad-key").forEach((key) => {
          key.classList.remove("selected");
        });
        const selected = keypadGrid.querySelector(`[data-index="${keypadSelection}"]`);
        if (selected) selected.classList.add("selected");
      }

      function handleKeypadInput(key) {
        const columns = 3;
        const rows = Math.ceil(keypadLayout.length / columns);
        const row = Math.floor(keypadSelection / columns);
        const col = keypadSelection % columns;
        let nextRow = row;
        let nextCol = col;
        if (key === "ArrowUp") nextRow = Math.max(0, row - 1);
        if (key === "ArrowDown") nextRow = Math.min(rows - 1, row + 1);
        if (key === "ArrowLeft") nextCol = Math.max(0, col - 1);
        if (key === "ArrowRight") nextCol = Math.min(columns - 1, col + 1);
        const nextIndex = nextRow * columns + nextCol;
        if (nextIndex < keypadLayout.length) {
          keypadSelection = nextIndex;
        }
        updateKeypadSelection();
        pressKeypadKey(keypadLayout[keypadSelection]);
      }

      function pressKeypadKey(key) {
        if (key === "clear") {
          keypadInput = "";
          updateKeypadDisplay();
          return;
        }
        if (key === "enter") {
          if (keypadInput === targetCode) {
            keypadOverlay.classList.remove("visible");
            addMemory("Remembering puzzles");
            startLockPuzzle();
          } else {
            keypadInput = "";
            updateKeypadDisplay("Try again");
          }
          return;
        }
        if (keypadInput.length >= targetCode.length) {
          return;
        }
        const mapped = scrambledMap[key];
        keypadInput += mapped;
        updateKeypadDisplay();
      }

      function updateKeypadDisplay(message) {
        if (message) {
          keypadDisplay.textContent = message;
          return;
        }
        const displayText = keypadInput.padEnd(targetCode.length, "-");
        keypadDisplay.textContent = displayText.split("").join(" ");
      }

      function startKeypadPuzzle() {
        state.phase = "keypad";
        keypadOverlay.classList.add("visible");
        keypadInput = "";
        keypadSelection = 0;
        updateKeypadDisplay();
        updateKeypadSelection();
        setHint("Solve the keypad puzzle using only the arrow keys.");
      }

      function buildLockControls() {
        lockControls.innerHTML = "";
        lockLayers.forEach((_, index) => {
          const buttonLeft = document.createElement("button");
          buttonLeft.className = "lock-button";
          buttonLeft.textContent = `Layer ${index + 1} â—€`;
          buttonLeft.addEventListener("click", () => rotateLockLayer(index, -1));
          const buttonRight = document.createElement("button");
          buttonRight.className = "lock-button";
          buttonRight.textContent = `Layer ${index + 1} â–¶`;
          buttonRight.addEventListener("click", () => rotateLockLayer(index, 1));
          lockControls.appendChild(buttonLeft);
          lockControls.appendChild(buttonRight);
        });
      }

      function renderLockLayers() {
        lockLayersEl.innerHTML = "";
        lockLayers.forEach((value, index) => {
          const layer = document.createElement("div");
          layer.className = "lock-layer";
          for (let i = 0; i < 6; i += 1) {
            const dot = document.createElement("span");
            if (i === value) dot.classList.add("active");
            if (i === lockTargets[index]) dot.classList.add("target");
            dot.textContent = i + 1;
            layer.appendChild(dot);
          }
          lockLayersEl.appendChild(layer);
        });
      }

      function rotateLockLayer(layerIndex, direction) {
        lockLayers[layerIndex] = (lockLayers[layerIndex] + direction + 6) % 6;
        renderLockLayers();
        checkLockSolved();
      }

      function checkLockSolved() {
        const solved = lockLayers.every((value, index) => value === lockTargets[index]);
        if (solved) {
          lockMessage.textContent = "Lock opened! The wires are exposed.";
          setTimeout(() => {
            lockOverlay.classList.remove("visible");
            startWiresPuzzle();
          }, 800);
        }
      }

      function startLockPuzzle() {
        state.phase = "lock";
        lockLayers = [0, 4, 1];
        lockMessage.textContent = "";
        lockOverlay.classList.add("visible");
        buildLockControls();
        renderLockLayers();
        setHint("Twist the lock layers so the green markers align.");
      }

      function buildWireBoard() {
        wireLeft.innerHTML = "";
        wireRight.innerHTML = "";
        wireLinks.textContent = "No connections yet.";
        wireMessage.textContent = "";
        wireSelected = null;
        wireConnections.clear();
        const shuffledRight = [...wireColors].sort(() => Math.random() - 0.5);
        wireColors.forEach((color) => {
          const leftBtn = document.createElement("button");
          leftBtn.className = "wire-terminal";
          leftBtn.style.background = color;
          leftBtn.dataset.color = color;
          leftBtn.dataset.side = "left";
          leftBtn.textContent = color.toUpperCase();
          leftBtn.addEventListener("click", () => selectWire(color, "left", leftBtn));
          wireLeft.appendChild(leftBtn);
        });
        shuffledRight.forEach((color) => {
          const rightBtn = document.createElement("button");
          rightBtn.className = "wire-terminal";
          rightBtn.style.background = color;
          rightBtn.dataset.color = color;
          rightBtn.dataset.side = "right";
          rightBtn.textContent = color.toUpperCase();
          rightBtn.addEventListener("click", () => selectWire(color, "right", rightBtn));
          wireRight.appendChild(rightBtn);
        });
      }

      function updateWireLinks() {
        if (wireConnections.size === 0) {
          wireLinks.textContent = "No connections yet.";
          return;
        }
        wireLinks.innerHTML = "";
        wireConnections.forEach((color) => {
          const line = document.createElement("div");
          line.textContent = `${color.toUpperCase()} linked`;
          wireLinks.appendChild(line);
        });
      }

      function selectWire(color, side, button) {
        if (wireConnections.has(color)) {
          return;
        }
        if (side === "left") {
          wireSelected = color;
          wireLeft.querySelectorAll(".wire-terminal").forEach((node) => node.classList.remove("selected"));
          button.classList.add("selected");
          wireMessage.textContent = "Pick the matching color on the right.";
          return;
        }
        if (!wireSelected) {
          wireMessage.textContent = "Pick a wire on the left first.";
          return;
        }
        if (wireSelected === color) {
          wireConnections.add(color);
          wireMessage.textContent = `${color.toUpperCase()} connected!`;
          markWireConnected(color);
          updateWireLinks();
          wireSelected = null;
          if (wireConnections.size === wireColors.length) {
            setTimeout(() => {
              wireMessage.textContent = "All wires linked. The memory console hums.";
              wiresOverlay.classList.remove("visible");
              startMemoryPuzzle();
            }, 700);
          }
        } else {
          wireMessage.textContent = "Wrong match. Try again.";
          wireSelected = null;
          wireLeft.querySelectorAll(".wire-terminal").forEach((node) => node.classList.remove("selected"));
        }
      }

      function markWireConnected(color) {
        document.querySelectorAll(`.wire-terminal[data-color="${color}"]`).forEach((node) => {
          node.classList.add("connected");
          node.classList.remove("selected");
        });
      }

      function startWiresPuzzle() {
        state.phase = "wires";
        wiresOverlay.classList.add("visible");
        buildWireBoard();
        setHint("Connect matching color wires to restore power.");
      }

      function buildMemoryButtons() {
        memoryGrid.innerHTML = "";
        memoryColors.forEach((color) => {
          const button = document.createElement("button");
          button.className = `memory-button ${color}`;
          button.dataset.color = color;
          button.addEventListener("click", () => handleMemoryInput(color));
          memoryGrid.appendChild(button);
        });
      }

      function updateMemoryScore() {
        const score = Math.max(0, memorySequence.length - 1);
        memoryScore.textContent = `Score: ${score} / 10`;
      }

      function flashMemoryButton(color) {
        const button = memoryGrid.querySelector(`[data-color="${color}"]`);
        if (!button) return;
        button.classList.add("active");
        setTimeout(() => button.classList.remove("active"), 350);
      }

      async function playMemorySequence() {
        memoryLocked = true;
        memoryMessage.textContent = "Watch carefully...";
        for (const color of memorySequence) {
          flashMemoryButton(color);
          await new Promise((resolve) => setTimeout(resolve, 550));
        }
        memoryLocked = false;
        memoryInputIndex = 0;
        memoryMessage.textContent = "Your turn!";
      }

      function nextMemoryRound() {
        const nextColor = memoryColors[Math.floor(Math.random() * memoryColors.length)];
        memorySequence.push(nextColor);
        updateMemoryScore();
        playMemorySequence();
      }

      function handleMemoryInput(color) {
        if (memoryLocked) {
          return;
        }
        flashMemoryButton(color);
        if (color !== memorySequence[memoryInputIndex]) {
          memoryMessage.textContent = "Oops! Try the sequence again.";
          memoryInputIndex = 0;
          playMemorySequence();
          return;
        }
        memoryInputIndex += 1;
        if (memoryInputIndex === memorySequence.length) {
          if (Math.max(0, memorySequence.length - 1) >= 10) {
            memoryMessage.textContent = "Memory sync complete!";
            setTimeout(() => {
              memoryOverlay.classList.remove("visible");
              unlockWalking();
            }, 800);
            return;
          }
          memoryMessage.textContent = "Nice! Get ready for the next sequence.";
          setTimeout(() => nextMemoryRound(), 900);
        }
      }

      function startMemoryPuzzle() {
        state.phase = "memory";
        memoryOverlay.classList.add("visible");
        memorySequence = [];
        memoryInputIndex = 0;
        memoryMessage.textContent = "";
        buildMemoryButtons();
        updateMemoryScore();
        setHint("Repeat the color sequence. Reach a score of 10.");
        setTimeout(() => nextMemoryRound(), 600);
      }

      function init() {
        placeCharacters();
        updateMemoryList();
        buildKeypad();
        setHint("You wake up in a hospital bed. The nurse is coming to talk.");
        animateNurseApproach();
        setTimeout(() => startIntroDialogue(), 2400);
      }

      init();
    </script>
  </body>
</html>
