<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Stickman Concussion Adventure</title>
    <style>
      :root {
        --sky: #bde8ff;
        --floor: #d8f5c1;
        --hospital: #f5f0ff;
        --panel: rgba(255, 255, 255, 0.85);
        --accent: #ff7a7a;
        --ink: #2c2c2c;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Comic Sans MS", "Trebuchet MS", system-ui, sans-serif;
        background: linear-gradient(180deg, var(--sky), #ffffff);
        color: var(--ink);
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
      }

      #game-wrapper {
        width: 900px;
        max-width: 96vw;
        aspect-ratio: 16 / 9;
        background: var(--hospital);
        border: 5px solid var(--ink);
        border-radius: 18px;
        position: relative;
        overflow: hidden;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.15);
      }

      #scene {
        position: absolute;
        inset: 0;
        background: linear-gradient(180deg, #f6fbff 0%, #fff5f5 55%, var(--floor) 55%);
        transition: background 0.6s ease;
      }

      #scene.cafe {
        background: linear-gradient(180deg, #f2e9e1 0%, #e8d6c3 55%, #cbb48f 55%);
      }

      .ground-line {
        position: absolute;
        left: 0;
        right: 0;
        height: 6px;
        background: #86c27c;
        top: 55%;
      }

      #player,
      .npc {
        position: absolute;
        width: 48px;
        height: 96px;
      }

      .stick-body {
        position: absolute;
        left: 50%;
        top: 18px;
        width: 6px;
        height: 60px;
        background: var(--ink);
        transform: translateX(-50%);
      }

      .stick-head {
        position: absolute;
        top: 0;
        left: 50%;
        width: 30px;
        height: 30px;
        border: 4px solid var(--ink);
        border-radius: 50%;
        transform: translateX(-50%);
        background: #fff;
      }

      .stick-arm {
        position: absolute;
        width: 32px;
        height: 6px;
        background: var(--ink);
        top: 40px;
      }

      .stick-arm.left {
        left: 4px;
        transform: rotate(-20deg);
        transform-origin: left center;
      }

      .stick-arm.right {
        right: 4px;
        transform: rotate(20deg);
        transform-origin: right center;
      }

      .stick-leg {
        position: absolute;
        width: 6px;
        height: 36px;
        background: var(--ink);
        bottom: 0;
      }

      .stick-leg.left {
        left: 16px;
        transform: rotate(8deg);
      }

      .stick-leg.right {
        right: 16px;
        transform: rotate(-8deg);
      }

      #player.bedridden {
        transform: rotate(90deg);
      }

      #player .speech {
        position: absolute;
        top: -22px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 12px;
        background: #fff;
        padding: 4px 6px;
        border-radius: 8px;
        border: 2px solid var(--ink);
        display: none;
      }

      #player.talking .speech {
        display: block;
      }

      .npc {
        filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.2));
        cursor: pointer;
      }

      .npc .label {
        position: absolute;
        top: -22px;
        left: 50%;
        transform: translateX(-50%);
        background: #fff;
        border: 2px solid var(--ink);
        padding: 2px 6px;
        border-radius: 8px;
        font-size: 12px;
      }

      #hint-panel {
        position: absolute;
        top: 18px;
        left: 18px;
        width: 260px;
        background: var(--panel);
        border: 3px solid var(--ink);
        border-radius: 14px;
        padding: 12px 14px;
        font-size: 14px;
      }

      #hint-panel h3 {
        margin: 0 0 6px;
        font-size: 16px;
      }

      #dialogue {
        position: absolute;
        left: 50%;
        bottom: 18px;
        transform: translateX(-50%);
        width: min(640px, 92%);
        background: rgba(255, 255, 255, 0.95);
        border: 4px solid var(--ink);
        border-radius: 16px;
        padding: 16px;
        text-align: center;
        display: none;
      }

      #dialogue.visible {
        display: block;
      }

      #dialogue .speaker {
        font-weight: 700;
        margin-bottom: 6px;
      }

      .puzzle-overlay {
        position: absolute;
        inset: 0;
        background: rgba(0, 0, 0, 0.35);
        display: none;
        align-items: center;
        justify-content: center;
        padding: 16px;
      }

      .puzzle-overlay.visible {
        display: flex;
      }

      .puzzle-panel {
        background: #fff;
        border: 4px solid var(--ink);
        border-radius: 18px;
        padding: 16px 20px;
        width: min(360px, 90%);
        text-align: center;
      }

      .puzzle-panel h4 {
        margin: 0 0 8px;
        font-size: 18px;
      }

      #sticky-note {
        background: #fff9a9;
        border: 2px solid #d4c863;
        border-radius: 12px;
        padding: 6px 10px;
        font-size: 13px;
        margin: 8px auto;
        width: fit-content;
      }

      #keypad-display {
        font-size: 22px;
        letter-spacing: 4px;
        padding: 8px 0;
        border: 2px dashed var(--ink);
        border-radius: 10px;
        margin-bottom: 10px;
      }

      #keypad-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
      }

      .keypad-key {
        background: #f2f2f2;
        border: 2px solid var(--ink);
        border-radius: 10px;
        padding: 10px 0;
        font-size: 18px;
        font-weight: 700;
      }

      .keypad-key.selected {
        background: var(--accent);
        color: #fff;
      }

      #keypad-hint {
        margin-top: 10px;
        font-size: 12px;
      }

      .lock-layer {
        display: flex;
        justify-content: center;
        gap: 6px;
        margin: 10px 0;
        font-size: 12px;
      }

      .lock-layer span {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 2px solid var(--ink);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        background: #f5f5f5;
      }

      .lock-layer span.active {
        background: var(--accent);
        color: #fff;
      }

      .lock-layer span.target {
        border-color: #1a8f4e;
        box-shadow: 0 0 0 2px rgba(26, 143, 78, 0.3);
      }

      .lock-controls {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
        margin-top: 10px;
      }

      .lock-button,
      .wire-terminal,
      .memory-button {
        border: 2px solid var(--ink);
        border-radius: 10px;
        padding: 8px;
        font-weight: 700;
        cursor: pointer;
        background: #f2f2f2;
      }

      .lock-button {
        font-size: 12px;
      }

      .wire-board {
        display: grid;
        grid-template-columns: 1fr auto 1fr;
        gap: 12px;
        align-items: center;
        margin-top: 12px;
      }

      .wire-column {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .wire-terminal.connected {
        background: #c7f5c0;
      }

      .wire-terminal.selected {
        outline: 3px solid var(--accent);
      }

      .wire-links {
        font-size: 12px;
        line-height: 1.4;
      }

      .memory-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        margin-top: 12px;
      }

      .memory-button {
        height: 70px;
        font-size: 0;
      }

      .memory-button.red {
        background: #ff6b6b;
      }

      .memory-button.blue {
        background: #6ba9ff;
      }

      .memory-button.green {
        background: #6bff95;
      }

      .memory-button.yellow {
        background: #ffe26b;
      }

      .memory-button.active {
        box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.8) inset;
        filter: brightness(1.15);
      }

      #memory-panel {
        position: absolute;
        top: 18px;
        right: 18px;
        width: 200px;
        background: var(--panel);
        border: 3px solid var(--ink);
        border-radius: 14px;
        padding: 10px 12px;
        font-size: 13px;
      }

      #memory-panel ul {
        padding-left: 18px;
        margin: 6px 0 0;
      }

      #scene-message {
        position: absolute;
        top: 60%;
        right: 40px;
        background: #fff;
        border: 3px dashed var(--accent);
        padding: 8px 12px;
        border-radius: 12px;
        font-size: 14px;
        display: none;
      }

      #scene-message.visible {
        display: block;
      }

      .order-bubble {
        position: absolute;
        top: -42px;
        left: 50%;
        transform: translateX(-50%);
        background: #fff7e6;
        border: 3px solid var(--ink);
        border-radius: 14px;
        padding: 6px 8px;
        font-size: 12px;
        cursor: pointer;
        display: none;
        box-shadow: 0 6px 0 rgba(0, 0, 0, 0.08);
      }

      .order-bubble.visible {
        display: block;
        animation: pop 0.25s ease;
      }

      @keyframes pop {
        0% {
          transform: translateX(-50%) scale(0.92);
        }
        100% {
          transform: translateX(-50%) scale(1);
        }
      }

      .customer-panel {
        position: absolute;
        top: 18px;
        left: 300px;
        width: 260px;
        background: var(--panel);
        border: 3px solid var(--ink);
        border-radius: 14px;
        padding: 10px 12px;
        font-size: 13px;
        display: none;
      }

      .customer-panel.visible {
        display: block;
      }

      .customer-panel h4 {
        margin: 0 0 6px;
        font-size: 15px;
      }

      .customer-panel .order-line {
        margin: 2px 0;
      }

      .coffee-panel {
        width: min(520px, 96vw);
      }

      .coffee-order-steps {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 8px;
        margin: 10px 0;
      }

      .coffee-slot {
        border: 2px dashed var(--ink);
        border-radius: 10px;
        padding: 10px;
        min-height: 52px;
        background: #fffdf6;
        font-size: 13px;
      }

      .coffee-slot.filled {
        border-style: solid;
        background: #e6ffe8;
        font-weight: 700;
      }

      .ingredient-tray {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 10px;
        margin-top: 12px;
      }

      .ingredient {
        border: 2px solid var(--ink);
        border-radius: 10px;
        padding: 8px;
        background: #f7f2ff;
        cursor: grab;
        font-weight: 700;
      }

      .ingredient.exhausted {
        opacity: 0.4;
        cursor: not-allowed;
      }

      .coffee-footer {
        margin-top: 12px;
        display: flex;
        justify-content: space-between;
        gap: 8px;
        flex-wrap: wrap;
      }

      .coffee-footer button {
        flex: 1;
      }

      @media (max-width: 640px) {
        #hint-panel,
        #memory-panel {
          width: 180px;
          font-size: 12px;
        }

        .puzzle-panel {
          width: min(320px, 92%);
        }
      }
    </style>
  </head>
  <body>
    <div id="game-wrapper">
      <div id="scene">
        <div class="ground-line"></div>
        <div id="player" class="bedridden">
          <div class="speech">Hello?</div>
          <div class="stick-head"></div>
          <div class="stick-body"></div>
          <div class="stick-arm left"></div>
          <div class="stick-arm right"></div>
          <div class="stick-leg left"></div>
          <div class="stick-leg right"></div>
        </div>
        <div id="nurse" class="npc">
          <div class="label">Nurse?</div>
          <div class="stick-head"></div>
          <div class="stick-body"></div>
          <div class="stick-arm left"></div>
          <div class="stick-arm right"></div>
          <div class="stick-leg left"></div>
          <div class="stick-leg right"></div>
        </div>
        <div id="kid" class="npc" hidden>
          <div class="label">Barista</div>
          <button id="customer-bubble" class="order-bubble" type="button" hidden>
            Take order
          </button>
          <div class="stick-head"></div>
          <div class="stick-body"></div>
          <div class="stick-arm left"></div>
          <div class="stick-arm right"></div>
          <div class="stick-leg left"></div>
          <div class="stick-leg right"></div>
        </div>
        <div id="scene-message">Cafe scene unlocked!</div>
      </div>
      <div id="hint-panel">
        <h3>ðŸ’¡ Hint</h3>
        <div id="hint-text"></div>
      </div>
      <div id="memory-panel">
        <strong>Recovered Memories</strong>
        <ul id="memory-list"></ul>
      </div>
      <div id="customer-panel" class="customer-panel" hidden>
        <h4>Customer Waiting</h4>
        <div class="order-line" id="customer-name"></div>
        <div class="order-line" id="customer-order"></div>
        <div class="order-line" id="customer-progress"></div>
      </div>
      <div id="dialogue">
        <div class="speaker" id="dialogue-speaker"></div>
        <div id="dialogue-text"></div>
      </div>
      <div id="keypad-overlay" class="puzzle-overlay">
        <div id="keypad" class="puzzle-panel">
          <h4>Hospital Door Keypad</h4>
          <div id="sticky-note">Sticky note: Code 428</div>
          <div id="keypad-display">---</div>
          <div id="keypad-grid"></div>
          <div id="keypad-hint">
            Use arrow keys to move. Each move onto a key presses it.
          </div>
          <div id="keypad-hint">Number keys also work.</div>
        </div>
      </div>
      <div id="lock-overlay" class="puzzle-overlay">
        <div class="puzzle-panel">
          <h4>Twist Lock Alignment</h4>
          <div>Align each ring on the green marker.</div>
          <div id="lock-layers"></div>
          <div class="lock-controls" id="lock-controls"></div>
          <div id="lock-message"></div>
        </div>
      </div>
      <div id="wires-overlay" class="puzzle-overlay">
        <div class="puzzle-panel">
          <h4>Wire Connection</h4>
          <div>Connect matching colors to restore power.</div>
          <div class="wire-board">
            <div class="wire-column" id="wire-left"></div>
            <div class="wire-links" id="wire-links">No connections yet.</div>
            <div class="wire-column" id="wire-right"></div>
          </div>
          <div id="wire-message"></div>
        </div>
      </div>
      <div id="memory-overlay" class="puzzle-overlay">
        <div class="puzzle-panel">
          <h4>Memory Echo Game</h4>
          <div>Watch the colors, then repeat the sequence.</div>
          <div id="memory-score">Score: 0 / 10</div>
          <div class="memory-grid" id="memory-grid"></div>
          <div id="memory-message"></div>
        </div>
      </div>
      <div id="coffee-overlay" class="puzzle-overlay">
        <div class="puzzle-panel coffee-panel">
          <h4>Cafe Order Builder</h4>
          <div id="coffee-order-title"></div>
          <div class="coffee-order-steps" id="coffee-order-steps"></div>
          <div><strong>Drag ingredients in order:</strong></div>
          <div class="ingredient-tray" id="ingredient-tray"></div>
          <div id="coffee-status"></div>
          <div class="coffee-footer">
            <button id="reset-coffee" class="lock-button" type="button">Reset drink</button>
            <button id="close-coffee" class="lock-button" type="button">Close</button>
          </div>
        </div>
      </div>
    </div>

    <script>
      const player = document.getElementById("player");
      const nurse = document.getElementById("nurse");
      const kid = document.getElementById("kid");
      const scene = document.getElementById("scene");
      const hintText = document.getElementById("hint-text");
      const dialogueBox = document.getElementById("dialogue");
      const dialogueSpeaker = document.getElementById("dialogue-speaker");
      const dialogueText = document.getElementById("dialogue-text");
      const memoryList = document.getElementById("memory-list");
      const sceneMessage = document.getElementById("scene-message");
      const keypadOverlay = document.getElementById("keypad-overlay");
      const keypadGrid = document.getElementById("keypad-grid");
      const keypadDisplay = document.getElementById("keypad-display");
      const lockOverlay = document.getElementById("lock-overlay");
      const lockLayersEl = document.getElementById("lock-layers");
      const lockControls = document.getElementById("lock-controls");
      const lockMessage = document.getElementById("lock-message");
      const wiresOverlay = document.getElementById("wires-overlay");
      const wireLeft = document.getElementById("wire-left");
      const wireRight = document.getElementById("wire-right");
      const wireLinks = document.getElementById("wire-links");
      const wireMessage = document.getElementById("wire-message");
      const memoryOverlay = document.getElementById("memory-overlay");
      const memoryGrid = document.getElementById("memory-grid");
      const memoryScore = document.getElementById("memory-score");
      const memoryMessage = document.getElementById("memory-message");
      const customerBubble = document.getElementById("customer-bubble");
      const customerPanel = document.getElementById("customer-panel");
      const customerName = document.getElementById("customer-name");
      const customerOrderText = document.getElementById("customer-order");
      const customerProgress = document.getElementById("customer-progress");
      const coffeeOverlay = document.getElementById("coffee-overlay");
      const coffeeOrderTitle = document.getElementById("coffee-order-title");
      const coffeeSlotsEl = document.getElementById("coffee-order-steps");
      const ingredientTray = document.getElementById("ingredient-tray");
      const coffeeStatus = document.getElementById("coffee-status");
      const resetCoffeeBtn = document.getElementById("reset-coffee");
      const closeCoffeeBtn = document.getElementById("close-coffee");

      const state = {
        canWalk: false,
        inDialogue: false,
        scene: "hospital",
        phase: "intro",
        memories: [],
        position: { x: 120, y: 320 },
        ordersServed: 0,
        coffeeMemoryGiven: false,
      };

      const dialogueScripts = {
        nurse: [
          {
            speaker: "Stickman",
            text: "Goodbye. Tomato salad solves all problems. Why I have no tomato salad?",
          },
          {
            speaker: "Nurse",
            text: "I'm your nurse. You have a concussion, so we will go slow.",
          },
          {
            speaker: "Stickman",
            text: "Fish tanks are very tasty, especially ones with french fries",
          },
          {
            speaker: "Nurse",
            text: "Solve this keypad puzzle. The code is on the sticky note, but your fingers are scrambled.",
          },
          {
            speaker: "Nurse",
            text: "Each number you press becomes a different number. Figure out the right buttons.",
          },
        ],
        baristaIntro: [
          {
            speaker: "Barista",
            text: "Welcome to my cafe! Could you jump behind the bar and help with coffees?",
          },
          {
            speaker: "Stickman",
            text: "[jabbing at boba] Why these bubbles no pop. Is it because tomato salad missing croutons?",
          },
          {
            speaker: "Barista",
            text: "Click my speech bubble to take each customer's order. Match every ingredient, in order and amount.",
          },
          {
            speaker: "Stickman",
            text: "Sad people leaving with unpoppable bubbles will put croutons back in tomato salad",
          },
        ],
        baristaMemory: [
          {
            speaker: "Barista",
            text: "Ten satisfied customers! You nailed every pour and swirl.",
          },
          {
            speaker: "Barista",
            text: "Take this memory of eating and drinking. You earned it.",
          },
          {
            speaker: "Stickman",
            text: "Mugs and meals! My brain buzzes with flavor again.",
          },
        ],
      };

      let dialogueQueue = [];
      let dialogueCompleteCb = null;
      const keypadLayout = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "clear", "0", "enter"];
      const scrambledMap = {
        0: "5",
        1: "3",
        2: "8",
        3: "1",
        4: "6",
        5: "0",
        6: "2",
        7: "9",
        8: "4",
        9: "7",
      };
      const targetCode = "428";
      let keypadSelection = 0;
      let keypadInput = "";
      let nurseApproachTimer;
      let nurseArrived = false;
      let introDialogueStarted = false;
      const lockTargets = [2, 2, 2];
      let lockLayers = [0, 4, 1];
      const wireColors = ["red", "blue", "green", "yellow"];
      let wireSelected = null;
      const wireConnections = new Set();
      const memoryColors = ["red", "blue", "green", "yellow"];
      let memorySequence = [];
      let memoryInputIndex = 0;
      let memoryLocked = false;
      const coffeeOrders = [
        {
          customer: "Riley the Runner",
          request: "Latte: 2 espresso shots, 2 steamed milk, finish with foam.",
          steps: ["Espresso Shot", "Espresso Shot", "Steamed Milk", "Steamed Milk", "Milk Foam"],
        },
        {
          customer: "Avery the Artist",
          request: "Iced mocha: espresso, chocolate syrup, cold milk, ice cubes.",
          steps: ["Espresso Shot", "Chocolate Syrup", "Cold Milk", "Ice Cubes"],
        },
        {
          customer: "Jules the Journalist",
          request: "Flat white: double espresso, silky milk.",
          steps: ["Espresso Shot", "Espresso Shot", "Steamed Milk"],
        },
        {
          customer: "Morgan the Musician",
          request: "Caramel cappuccino: espresso, steamed milk, foam, caramel drizzle.",
          steps: ["Espresso Shot", "Steamed Milk", "Milk Foam", "Caramel Drizzle"],
        },
        {
          customer: "Casey the Coder",
          request: "Sweet cinnamon latte: espresso, steamed milk, sugar, cinnamon.",
          steps: ["Espresso Shot", "Steamed Milk", "Sugar", "Cinnamon"],
        },
      ];
      const extraIngredients = ["Whipped Cream", "Vanilla Syrup", "Honey"];
      let baristaIntroStarted = false;
      let baristaIntroComplete = false;
      let currentCoffeeOrder = null;
      let coffeeSlots = [];
      let coffeeStock = {};
      let coffeeOverlayOpen = false;

      function updateMemoryList() {
        memoryList.innerHTML = "";
        if (state.memories.length === 0) {
          const li = document.createElement("li");
          li.textContent = "None yet!";
          memoryList.appendChild(li);
          return;
        }
        state.memories.forEach((memory) => {
          const li = document.createElement("li");
          li.textContent = memory;
          memoryList.appendChild(li);
        });
      }

      function setHint(text) {
        hintText.textContent = text;
      }

      function setPlayerPosition() {
        player.style.left = `${state.position.x}px`;
        player.style.top = `${state.position.y}px`;
      }

      function placeCharacters() {
        setPlayerPosition();
        nurse.style.left = "720px";
        nurse.style.top = "260px";
        kid.style.left = "560px";
        kid.style.top = "260px";
      }

      function openDialogue(scriptKey, onComplete) {
        dialogueQueue = [...dialogueScripts[scriptKey]];
        dialogueCompleteCb = onComplete || null;
        state.inDialogue = true;
        dialogueBox.classList.add("visible");
        showNextDialogue();
      }

      function showNextDialogue() {
        if (dialogueQueue.length === 0) {
          closeDialogue();
          return;
        }
        const line = dialogueQueue.shift();
        dialogueSpeaker.textContent = line.speaker;
        dialogueText.textContent = line.text;
      }

      function closeDialogue() {
        state.inDialogue = false;
        dialogueBox.classList.remove("visible");
        const callback = dialogueCompleteCb;
        dialogueCompleteCb = null;
        if (callback) {
          callback();
        } else if (state.scene === "hospital" && state.phase === "intro") {
          startKeypadPuzzle();
        }
      }

      function unlockWalking() {
        state.canWalk = true;
        state.phase = "free";
        addMemory("Remembering walking");
        player.classList.remove("bedridden");
        setHint("You remembered how to walk! Use the arrow keys to move.");
        if (state.scene === "cafe" && baristaIntroComplete && !coffeeOverlayOpen) {
          promptCustomerOrder();
        }
      }

      function addMemory(memory) {
        if (!state.memories.includes(memory)) {
          state.memories.push(memory);
          updateMemoryList();
        }
      }

      function isNear(a, b, padding = 24) {
        const aRect = a.getBoundingClientRect();
        const bRect = b.getBoundingClientRect();
        const aCenter = { x: (aRect.left + aRect.right) / 2, y: (aRect.top + aRect.bottom) / 2 };
        const bCenter = { x: (bRect.left + bRect.right) / 2, y: (bRect.top + bRect.bottom) / 2 };
        const dx = aCenter.x - bCenter.x;
        const dy = aCenter.y - bCenter.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const reach = Math.max(aRect.width, aRect.height) / 2 + Math.max(bRect.width, bRect.height) / 2 + padding;
        return distance <= reach;
      }

      function handleInteraction() {
        if (state.inDialogue) {
          showNextDialogue();
          return;
        }
        if (state.scene === "cafe" && isNear(player, kid, 36)) {
          if (!baristaIntroComplete && !baristaIntroStarted) {
            baristaIntroStarted = true;
            openDialogue("baristaIntro", () => {
              baristaIntroComplete = true;
              startCoffeeService();
            });
            return;
          }
          if (baristaIntroComplete && !coffeeOverlayOpen) {
            promptCustomerOrder();
          }
        } else {
          hideCustomerBubble();
        }
      }

      function promptCustomerOrder() {
        if (!currentCoffeeOrder) {
          prepareNextCustomer();
        }
        updateCustomerPanel();
        showCustomerBubble(`${currentCoffeeOrder.customer}: tap to take order`);
      }

      function showCustomerBubble(text) {
        if (!currentCoffeeOrder) return;
        customerBubble.hidden = false;
        customerBubble.classList.add("visible");
        customerBubble.textContent = text || "Take order";
      }

      function hideCustomerBubble() {
        customerBubble.classList.remove("visible");
        customerBubble.hidden = true;
      }

      function updateCustomerPanel() {
        if (!currentCoffeeOrder) {
          customerPanel.classList.remove("visible");
          customerPanel.hidden = true;
          return;
        }
        customerPanel.hidden = false;
        customerPanel.classList.add("visible");
        customerName.textContent = currentCoffeeOrder.customer;
        customerOrderText.textContent = currentCoffeeOrder.request;
        customerProgress.textContent = `Orders served: ${state.ordersServed} / 10`;
      }

      function prepareNextCustomer() {
        currentCoffeeOrder = coffeeOrders[Math.floor(Math.random() * coffeeOrders.length)];
        updateCustomerPanel();
        hideCustomerBubble();
      }

      function startCoffeeService() {
        prepareNextCustomer();
        setHint("Click the barista speech bubble to take each order and assemble the drink.");
        if (state.scene === "cafe" && isNear(player, kid, 36)) {
          showCustomerBubble(`${currentCoffeeOrder.customer}: tap to take order`);
        }
      }

      function buildCoffeeOverlay() {
        coffeeSlots = currentCoffeeOrder ? [...currentCoffeeOrder.steps] : [];
        coffeeStock = {};
        coffeeSlots.forEach((ingredient) => {
          coffeeStock[ingredient] = (coffeeStock[ingredient] || 0) + 1;
        });
        coffeeSlotsEl.innerHTML = "";
        coffeeSlots.forEach((ingredient, index) => {
          const slot = document.createElement("div");
          slot.className = "coffee-slot";
          slot.dataset.index = index;
          slot.textContent = `Step ${index + 1}`;
          slot.addEventListener("dragover", (event) => event.preventDefault());
          slot.addEventListener("drop", (event) => handleSlotDrop(event, ingredient, index));
          coffeeSlotsEl.appendChild(slot);
        });
        buildIngredientTray();
        coffeeStatus.textContent = "Drag each ingredient onto the correct step in order.";
        coffeeOrderTitle.textContent = `${currentCoffeeOrder.customer}'s order: ${currentCoffeeOrder.request}`;
      }

      function buildIngredientTray() {
        ingredientTray.innerHTML = "";
        const needed = new Set(coffeeSlots);
        extraIngredients.forEach((item) => needed.add(item));
        needed.forEach((ingredient) => {
          const button = document.createElement("div");
          button.className = "ingredient";
          button.draggable = true;
          button.dataset.ingredient = ingredient;
          button.textContent = `${ingredient}${coffeeStock[ingredient] ? ` x${coffeeStock[ingredient]}` : ""}`;
          button.addEventListener("dragstart", (event) => {
            if (button.classList.contains("exhausted")) {
              event.preventDefault();
              return;
            }
            event.dataTransfer.setData("text/plain", ingredient);
          });
          ingredientTray.appendChild(button);
        });
      }

      function handleSlotDrop(event, expectedIngredient, slotIndex) {
        event.preventDefault();
        const ingredient = event.dataTransfer.getData("text/plain");
        const slot = event.currentTarget;
        if (slot.classList.contains("filled")) {
          coffeeStatus.textContent = "That step is already filled.";
          return;
        }
        if (!coffeeStock[ingredient]) {
          coffeeStatus.textContent = `${ingredient} is not needed right now.`;
          return;
        }
        if (ingredient !== expectedIngredient) {
          coffeeStatus.textContent = `Wrong order. Step ${slotIndex + 1} needs ${expectedIngredient}.`;
          return;
        }
        coffeeStock[ingredient] -= 1;
        slot.classList.add("filled");
        slot.textContent = expectedIngredient;
        updateIngredientCounts();
        if ([...coffeeSlotsEl.children].every((node) => node.classList.contains("filled"))) {
          completeCoffeeOrder();
        } else {
          coffeeStatus.textContent = "Nice drop! Keep following the order.";
        }
      }

      function updateIngredientCounts() {
        ingredientTray.querySelectorAll(".ingredient").forEach((node) => {
          const ingredient = node.dataset.ingredient;
          if (coffeeStock[ingredient] !== undefined) {
            node.textContent = `${ingredient}${coffeeStock[ingredient] > 0 ? ` x${coffeeStock[ingredient]}` : ""}`;
            if (coffeeStock[ingredient] <= 0) {
              node.classList.add("exhausted");
            }
          }
        });
      }

      function resetCoffeeBoard() {
        if (!currentCoffeeOrder) return;
        buildCoffeeOverlay();
        coffeeStatus.textContent = "Drink reset. Follow the steps again.";
      }

      function completeCoffeeOrder() {
        state.ordersServed += 1;
        coffeeStatus.textContent = "Order served! The customer smiles.";
        updateCustomerPanel();
        setTimeout(() => {
          coffeeOverlay.classList.remove("visible");
          coffeeOverlayOpen = false;
          hideCustomerBubble();
          if (state.ordersServed >= 10 && !state.coffeeMemoryGiven) {
            state.coffeeMemoryGiven = true;
            openDialogue("baristaMemory", () => {
              addMemory("Remembering eating and drinking");
              setHint("Memory of meals restored. You can keep serving or explore.");
              sceneMessage.textContent = "Cafe memory unlocked!";
              sceneMessage.classList.add("visible");
            });
            return;
          }
          prepareNextCustomer();
          if (state.scene === "cafe" && isNear(player, kid, 36)) {
            showCustomerBubble(`${currentCoffeeOrder.customer}: tap to take order`);
          }
        }, 600);
      }

      function openCoffeeOrder() {
        if (!currentCoffeeOrder) {
          prepareNextCustomer();
        }
        coffeeOverlay.classList.add("visible");
        coffeeOverlayOpen = true;
        buildCoffeeOverlay();
        hideCustomerBubble();
      }

      customerBubble?.addEventListener("click", () => {
        if (!customerBubble.classList.contains("visible") || !currentCoffeeOrder) return;
        openCoffeeOrder();
      });

      kid.addEventListener("click", () => {
        if (state.scene !== "cafe") return;
        handleInteraction();
        if (baristaIntroComplete && !coffeeOverlayOpen) {
          promptCustomerOrder();
        }
      });

      resetCoffeeBtn.addEventListener("click", resetCoffeeBoard);
      closeCoffeeBtn.addEventListener("click", () => {
        coffeeOverlay.classList.remove("visible");
        coffeeOverlayOpen = false;
        if (state.scene === "cafe" && isNear(player, kid, 36)) {
          showCustomerBubble("Click to retake the order");
        } else {
          hideCustomerBubble();
        }
      });

      function movePlayer(dx, dy) {
        if (!state.canWalk) {
          player.classList.add("talking");
          setTimeout(() => player.classList.remove("talking"), 400);
          return;
        }
        if (state.inDialogue) {
          showNextDialogue();
          return;
        }
        const maxX = scene.clientWidth - 60;
        const maxY = scene.clientHeight - 120;
        state.position.x = Math.max(20, Math.min(maxX, state.position.x + dx));
        state.position.y = Math.max(200, Math.min(maxY, state.position.y + dy));
        setPlayerPosition();
        handleSceneExit();
        handleInteraction();
      }

      function handleSceneExit() {
        if (state.scene === "hospital" && state.position.x > scene.clientWidth - 80) {
          state.scene = "cafe";
          scene.classList.add("cafe");
          kid.hidden = false;
          nurse.hidden = true;
          state.position.x = 80;
          setPlayerPosition();
          setHint("Welcome to the cafe! Find the barista and stand close to talk.");
          if (baristaIntroComplete && !coffeeOverlayOpen) {
            promptCustomerOrder();
          }
        }
      }

      function onKeydown(event) {
        const key = event.key;
        const isSkipShortcut = event.ctrlKey && (key === "5" || event.code === "Digit5");
        if (isSkipShortcut) {
          event.preventDefault();
          skipLevel();
          return;
        }
        const isArrowKey = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(key);
        const isNumberKey = /^\d$/.test(key);
        if (!isArrowKey && !isNumberKey) {
          return;
        }
        event.preventDefault();
        if (state.inDialogue) {
          showNextDialogue();
          return;
        }
        if (state.phase === "intro" && !state.inDialogue) {
          startIntroDialogue(true);
          return;
        }
        if (state.phase === "keypad") {
          if (isNumberKey) {
            pressKeypadKey(key);
          } else {
            handleKeypadInput(key);
          }
          return;
        }
        if (state.phase !== "free") {
          return;
        }
        const step = 16;
        if (key === "ArrowUp") movePlayer(0, -step);
        if (key === "ArrowDown") movePlayer(0, step);
        if (key === "ArrowLeft") movePlayer(-step, 0);
        if (key === "ArrowRight") movePlayer(step, 0);
      }

      document.addEventListener("keydown", onKeydown);

      function skipLevel() {
        dialogueBox.classList.remove("visible");
        state.inDialogue = false;
        if (keypadOverlay.classList.contains("visible") || state.phase === "keypad") {
          keypadOverlay.classList.remove("visible");
          addMemory("Remembering puzzles");
          startLockPuzzle();
          return;
        }
        if (lockOverlay.classList.contains("visible") || state.phase === "lock") {
          lockOverlay.classList.remove("visible");
          startWiresPuzzle();
          return;
        }
        if (wiresOverlay.classList.contains("visible") || state.phase === "wires") {
          wiresOverlay.classList.remove("visible");
          startMemoryPuzzle();
          return;
        }
        if (memoryOverlay.classList.contains("visible") || state.phase === "memory") {
          memoryOverlay.classList.remove("visible");
          unlockWalking();
          return;
        }
        if (state.phase === "intro") {
          startKeypadPuzzle();
          return;
        }
        if (state.phase === "free" && state.scene === "hospital") {
          state.position.x = scene.clientWidth - 60;
          setPlayerPosition();
          handleSceneExit();
        }
      }

      function animateNurseApproach() {
        setHint("The nurse is walking over to check on you.");
        nurseArrived = false;
        nurseApproachTimer = setInterval(() => {
          const nurseX = Number.parseFloat(nurse.style.left) || 720;
          const targetX = state.position.x + 60;
          if (nurseX <= targetX) {
            clearInterval(nurseApproachTimer);
            nurseArrived = true;
            startIntroDialogue();
            return;
          }
          nurse.style.left = `${nurseX - 6}px`;
        }, 60);
      }

      function startIntroDialogue(forceSnap = false) {
        if (introDialogueStarted || state.inDialogue || state.phase !== "intro") {
          return;
        }
        introDialogueStarted = true;
        if (nurseApproachTimer) {
          clearInterval(nurseApproachTimer);
        }
        if (forceSnap || !nurseArrived) {
          nurse.style.left = `${state.position.x + 60}px`;
        }
        openDialogue("nurse", () => startKeypadPuzzle());
      }

      function buildKeypad() {
        keypadGrid.innerHTML = "";
        keypadLayout.forEach((key, index) => {
          const button = document.createElement("div");
          button.className = "keypad-key";
          button.dataset.index = index;
          button.textContent = key === "clear" ? "CLR" : key === "enter" ? "OK" : key;
          keypadGrid.appendChild(button);
        });
        updateKeypadSelection();
      }

      function updateKeypadSelection() {
        keypadGrid.querySelectorAll(".keypad-key").forEach((key) => {
          key.classList.remove("selected");
        });
        const selected = keypadGrid.querySelector(`[data-index="${keypadSelection}"]`);
        if (selected) selected.classList.add("selected");
      }

      function handleKeypadInput(key) {
        const columns = 3;
        const rows = Math.ceil(keypadLayout.length / columns);
        const row = Math.floor(keypadSelection / columns);
        const col = keypadSelection % columns;
        let nextRow = row;
        let nextCol = col;
        if (key === "ArrowUp") nextRow = Math.max(0, row - 1);
        if (key === "ArrowDown") nextRow = Math.min(rows - 1, row + 1);
        if (key === "ArrowLeft") nextCol = Math.max(0, col - 1);
        if (key === "ArrowRight") nextCol = Math.min(columns - 1, col + 1);
        const nextIndex = nextRow * columns + nextCol;
        if (nextIndex < keypadLayout.length) {
          keypadSelection = nextIndex;
        }
        updateKeypadSelection();
        pressKeypadKey(keypadLayout[keypadSelection]);
      }

      function pressKeypadKey(key) {
        if (key === "clear") {
          keypadInput = "";
          updateKeypadDisplay();
          return;
        }
        if (key === "enter") {
          if (keypadInput === targetCode) {
            keypadOverlay.classList.remove("visible");
            addMemory("Remembering puzzles");
            startLockPuzzle();
          } else {
            keypadInput = "";
            updateKeypadDisplay("Try again");
          }
          return;
        }
        if (keypadInput.length >= targetCode.length) {
          return;
        }
        const mapped = scrambledMap[key];
        keypadInput += mapped;
        updateKeypadDisplay();
      }

      function updateKeypadDisplay(message) {
        if (message) {
          keypadDisplay.textContent = message;
          return;
        }
        const displayText = keypadInput.padEnd(targetCode.length, "-");
        keypadDisplay.textContent = displayText.split("").join(" ");
      }

      function startKeypadPuzzle() {
        state.phase = "keypad";
        keypadOverlay.classList.add("visible");
        keypadInput = "";
        keypadSelection = 0;
        updateKeypadDisplay();
        updateKeypadSelection();
        setHint("Solve the keypad puzzle using only the arrow keys.");
      }

      function buildLockControls() {
        lockControls.innerHTML = "";
        lockLayers.forEach((_, index) => {
          const buttonLeft = document.createElement("button");
          buttonLeft.className = "lock-button";
          buttonLeft.textContent = `Layer ${index + 1} â—€`;
          buttonLeft.addEventListener("click", () => rotateLockLayer(index, -1));
          const buttonRight = document.createElement("button");
          buttonRight.className = "lock-button";
          buttonRight.textContent = `Layer ${index + 1} â–¶`;
          buttonRight.addEventListener("click", () => rotateLockLayer(index, 1));
          lockControls.appendChild(buttonLeft);
          lockControls.appendChild(buttonRight);
        });
      }

      function renderLockLayers() {
        lockLayersEl.innerHTML = "";
        lockLayers.forEach((value, index) => {
          const layer = document.createElement("div");
          layer.className = "lock-layer";
          for (let i = 0; i < 6; i += 1) {
            const dot = document.createElement("span");
            if (i === value) dot.classList.add("active");
            if (i === lockTargets[index]) dot.classList.add("target");
            dot.textContent = i + 1;
            layer.appendChild(dot);
          }
          lockLayersEl.appendChild(layer);
        });
      }

      function rotateLockLayer(layerIndex, direction) {
        lockLayers[layerIndex] = (lockLayers[layerIndex] + direction + 6) % 6;
        renderLockLayers();
        checkLockSolved();
      }

      function checkLockSolved() {
        const solved = lockLayers.every((value, index) => value === lockTargets[index]);
        if (solved) {
          lockMessage.textContent = "Lock opened! The wires are exposed.";
          setTimeout(() => {
            lockOverlay.classList.remove("visible");
            startWiresPuzzle();
          }, 800);
        }
      }

      function startLockPuzzle() {
        state.phase = "lock";
        lockLayers = [0, 4, 1];
        lockMessage.textContent = "";
        lockOverlay.classList.add("visible");
        buildLockControls();
        renderLockLayers();
        setHint("Twist the lock layers so the green markers align.");
      }

      function buildWireBoard() {
        wireLeft.innerHTML = "";
        wireRight.innerHTML = "";
        wireLinks.textContent = "No connections yet.";
        wireMessage.textContent = "";
        wireSelected = null;
        wireConnections.clear();
        const shuffledRight = [...wireColors].sort(() => Math.random() - 0.5);
        wireColors.forEach((color) => {
          const leftBtn = document.createElement("button");
          leftBtn.className = "wire-terminal";
          leftBtn.style.background = color;
          leftBtn.dataset.color = color;
          leftBtn.dataset.side = "left";
          leftBtn.textContent = color.toUpperCase();
          leftBtn.addEventListener("click", () => selectWire(color, "left", leftBtn));
          wireLeft.appendChild(leftBtn);
        });
        shuffledRight.forEach((color) => {
          const rightBtn = document.createElement("button");
          rightBtn.className = "wire-terminal";
          rightBtn.style.background = color;
          rightBtn.dataset.color = color;
          rightBtn.dataset.side = "right";
          rightBtn.textContent = color.toUpperCase();
          rightBtn.addEventListener("click", () => selectWire(color, "right", rightBtn));
          wireRight.appendChild(rightBtn);
        });
      }

      function updateWireLinks() {
        if (wireConnections.size === 0) {
          wireLinks.textContent = "No connections yet.";
          return;
        }
        wireLinks.innerHTML = "";
        wireConnections.forEach((color) => {
          const line = document.createElement("div");
          line.textContent = `${color.toUpperCase()} linked`;
          wireLinks.appendChild(line);
        });
      }

      function selectWire(color, side, button) {
        if (wireConnections.has(color)) {
          return;
        }
        if (side === "left") {
          wireSelected = color;
          wireLeft.querySelectorAll(".wire-terminal").forEach((node) => node.classList.remove("selected"));
          button.classList.add("selected");
          wireMessage.textContent = "Pick the matching color on the right.";
          return;
        }
        if (!wireSelected) {
          wireMessage.textContent = "Pick a wire on the left first.";
          return;
        }
        if (wireSelected === color) {
          wireConnections.add(color);
          wireMessage.textContent = `${color.toUpperCase()} connected!`;
          markWireConnected(color);
          updateWireLinks();
          wireSelected = null;
          if (wireConnections.size === wireColors.length) {
            setTimeout(() => {
              wireMessage.textContent = "All wires linked. The memory console hums.";
              wiresOverlay.classList.remove("visible");
              startMemoryPuzzle();
            }, 700);
          }
        } else {
          wireMessage.textContent = "Wrong match. Try again.";
          wireSelected = null;
          wireLeft.querySelectorAll(".wire-terminal").forEach((node) => node.classList.remove("selected"));
        }
      }

      function markWireConnected(color) {
        document.querySelectorAll(`.wire-terminal[data-color="${color}"]`).forEach((node) => {
          node.classList.add("connected");
          node.classList.remove("selected");
        });
      }

      function startWiresPuzzle() {
        state.phase = "wires";
        wiresOverlay.classList.add("visible");
        buildWireBoard();
        setHint("Connect matching color wires to restore power.");
      }

      function buildMemoryButtons() {
        memoryGrid.innerHTML = "";
        memoryColors.forEach((color) => {
          const button = document.createElement("button");
          button.className = `memory-button ${color}`;
          button.dataset.color = color;
          button.addEventListener("click", () => handleMemoryInput(color));
          memoryGrid.appendChild(button);
        });
      }

      function updateMemoryScore() {
        const score = Math.max(0, memorySequence.length - 1);
        memoryScore.textContent = `Score: ${score} / 10`;
      }

      function flashMemoryButton(color) {
        const button = memoryGrid.querySelector(`[data-color="${color}"]`);
        if (!button) return;
        button.classList.add("active");
        setTimeout(() => button.classList.remove("active"), 350);
      }

      async function playMemorySequence() {
        memoryLocked = true;
        memoryMessage.textContent = "Watch carefully...";
        for (const color of memorySequence) {
          flashMemoryButton(color);
          await new Promise((resolve) => setTimeout(resolve, 550));
        }
        memoryLocked = false;
        memoryInputIndex = 0;
        memoryMessage.textContent = "Your turn!";
      }

      function nextMemoryRound() {
        const nextColor = memoryColors[Math.floor(Math.random() * memoryColors.length)];
        memorySequence.push(nextColor);
        updateMemoryScore();
        playMemorySequence();
      }

      function handleMemoryInput(color) {
        if (memoryLocked) {
          return;
        }
        flashMemoryButton(color);
        if (color !== memorySequence[memoryInputIndex]) {
          memoryMessage.textContent = "Oops! Try the sequence again.";
          memoryInputIndex = 0;
          playMemorySequence();
          return;
        }
        memoryInputIndex += 1;
        if (memoryInputIndex === memorySequence.length) {
          if (Math.max(0, memorySequence.length - 1) >= 10) {
            memoryMessage.textContent = "Memory sync complete!";
            setTimeout(() => {
              memoryOverlay.classList.remove("visible");
              unlockWalking();
            }, 800);
            return;
          }
          memoryMessage.textContent = "Nice! Get ready for the next sequence.";
          setTimeout(() => nextMemoryRound(), 900);
        }
      }

      function startMemoryPuzzle() {
        state.phase = "memory";
        memoryOverlay.classList.add("visible");
        memorySequence = [];
        memoryInputIndex = 0;
        memoryMessage.textContent = "";
        buildMemoryButtons();
        updateMemoryScore();
        setHint("Repeat the color sequence. Reach a score of 10.");
        setTimeout(() => nextMemoryRound(), 600);
      }

      function init() {
        placeCharacters();
        updateMemoryList();
        buildKeypad();
        setHint("You wake up in a hospital bed. The nurse is coming to talk.");
        animateNurseApproach();
        setTimeout(() => startIntroDialogue(), 2400);
      }

      init();
    </script>
  </body>
</html>
